// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod golem {
    pub mod search_opensearch {
        /// Core types and error handling for universal search interfaces
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// Common structured errors for search operations
            #[derive(Clone)]
            pub enum SearchError {
                IndexNotFound,
                InvalidQuery(_rt::String),
                Unsupported,
                Internal(_rt::String),
                Timeout,
                RateLimited,
            }
            impl ::core::fmt::Debug for SearchError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        SearchError::IndexNotFound => {
                            f.debug_tuple("SearchError::IndexNotFound").finish()
                        }
                        SearchError::InvalidQuery(e) => {
                            f.debug_tuple("SearchError::InvalidQuery").field(e).finish()
                        }
                        SearchError::Unsupported => {
                            f.debug_tuple("SearchError::Unsupported").finish()
                        }
                        SearchError::Internal(e) => {
                            f.debug_tuple("SearchError::Internal").field(e).finish()
                        }
                        SearchError::Timeout => {
                            f.debug_tuple("SearchError::Timeout").finish()
                        }
                        SearchError::RateLimited => {
                            f.debug_tuple("SearchError::RateLimited").finish()
                        }
                    }
                }
            }
            impl ::core::fmt::Display for SearchError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for SearchError {}
            /// Identifier types
            pub type IndexName = _rt::String;
            pub type DocumentId = _rt::String;
            pub type Json = _rt::String;
            /// Document payload
            #[derive(Clone)]
            pub struct Doc {
                pub id: DocumentId,
                pub content: Json,
            }
            impl ::core::fmt::Debug for Doc {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Doc")
                        .field("id", &self.id)
                        .field("content", &self.content)
                        .finish()
                }
            }
            /// Highlight configuration
            #[derive(Clone)]
            pub struct HighlightConfig {
                pub fields: _rt::Vec<_rt::String>,
                pub pre_tag: Option<_rt::String>,
                pub post_tag: Option<_rt::String>,
                pub max_length: Option<u32>,
            }
            impl ::core::fmt::Debug for HighlightConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("HighlightConfig")
                        .field("fields", &self.fields)
                        .field("pre-tag", &self.pre_tag)
                        .field("post-tag", &self.post_tag)
                        .field("max-length", &self.max_length)
                        .finish()
                }
            }
            /// Advanced search tuning
            #[derive(Clone)]
            pub struct SearchConfig {
                pub timeout_ms: Option<u32>,
                pub boost_fields: _rt::Vec<(_rt::String, f32)>,
                pub attributes_to_retrieve: _rt::Vec<_rt::String>,
                pub language: Option<_rt::String>,
                pub typo_tolerance: Option<bool>,
                pub exact_match_boost: Option<f32>,
                pub provider_params: Option<Json>,
            }
            impl ::core::fmt::Debug for SearchConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SearchConfig")
                        .field("timeout-ms", &self.timeout_ms)
                        .field("boost-fields", &self.boost_fields)
                        .field("attributes-to-retrieve", &self.attributes_to_retrieve)
                        .field("language", &self.language)
                        .field("typo-tolerance", &self.typo_tolerance)
                        .field("exact-match-boost", &self.exact_match_boost)
                        .field("provider-params", &self.provider_params)
                        .finish()
                }
            }
            /// Search request
            #[derive(Clone)]
            pub struct SearchQuery {
                pub q: Option<_rt::String>,
                pub filters: _rt::Vec<_rt::String>,
                pub sort: _rt::Vec<_rt::String>,
                pub facets: _rt::Vec<_rt::String>,
                pub page: Option<u32>,
                pub per_page: Option<u32>,
                pub offset: Option<u32>,
                pub highlight: Option<HighlightConfig>,
                pub config: Option<SearchConfig>,
            }
            impl ::core::fmt::Debug for SearchQuery {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SearchQuery")
                        .field("q", &self.q)
                        .field("filters", &self.filters)
                        .field("sort", &self.sort)
                        .field("facets", &self.facets)
                        .field("page", &self.page)
                        .field("per-page", &self.per_page)
                        .field("offset", &self.offset)
                        .field("highlight", &self.highlight)
                        .field("config", &self.config)
                        .finish()
                }
            }
            /// Search hit
            #[derive(Clone)]
            pub struct SearchHit {
                pub id: DocumentId,
                pub score: Option<f64>,
                pub content: Option<Json>,
                pub highlights: Option<Json>,
            }
            impl ::core::fmt::Debug for SearchHit {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SearchHit")
                        .field("id", &self.id)
                        .field("score", &self.score)
                        .field("content", &self.content)
                        .field("highlights", &self.highlights)
                        .finish()
                }
            }
            /// Search result set
            #[derive(Clone)]
            pub struct SearchResults {
                pub total: Option<u32>,
                pub page: Option<u32>,
                pub per_page: Option<u32>,
                pub hits: _rt::Vec<SearchHit>,
                pub facets: Option<Json>,
                pub took_ms: Option<u32>,
            }
            impl ::core::fmt::Debug for SearchResults {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SearchResults")
                        .field("total", &self.total)
                        .field("page", &self.page)
                        .field("per-page", &self.per_page)
                        .field("hits", &self.hits)
                        .field("facets", &self.facets)
                        .field("took-ms", &self.took_ms)
                        .finish()
                }
            }
            /// Field schema types
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum FieldType {
                Text,
                Keyword,
                Integer,
                Float,
                Boolean,
                Date,
                GeoPoint,
            }
            impl ::core::fmt::Debug for FieldType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        FieldType::Text => f.debug_tuple("FieldType::Text").finish(),
                        FieldType::Keyword => {
                            f.debug_tuple("FieldType::Keyword").finish()
                        }
                        FieldType::Integer => {
                            f.debug_tuple("FieldType::Integer").finish()
                        }
                        FieldType::Float => f.debug_tuple("FieldType::Float").finish(),
                        FieldType::Boolean => {
                            f.debug_tuple("FieldType::Boolean").finish()
                        }
                        FieldType::Date => f.debug_tuple("FieldType::Date").finish(),
                        FieldType::GeoPoint => {
                            f.debug_tuple("FieldType::GeoPoint").finish()
                        }
                    }
                }
            }
            impl FieldType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> FieldType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => FieldType::Text,
                        1 => FieldType::Keyword,
                        2 => FieldType::Integer,
                        3 => FieldType::Float,
                        4 => FieldType::Boolean,
                        5 => FieldType::Date,
                        6 => FieldType::GeoPoint,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Field definition
            #[derive(Clone)]
            pub struct SchemaField {
                pub name: _rt::String,
                pub type_: FieldType,
                pub required: bool,
                pub facet: bool,
                pub sort: bool,
                pub index: bool,
            }
            impl ::core::fmt::Debug for SchemaField {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SchemaField")
                        .field("name", &self.name)
                        .field("type", &self.type_)
                        .field("required", &self.required)
                        .field("facet", &self.facet)
                        .field("sort", &self.sort)
                        .field("index", &self.index)
                        .finish()
                }
            }
            /// Index schema
            #[derive(Clone)]
            pub struct Schema {
                pub fields: _rt::Vec<SchemaField>,
                pub primary_key: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for Schema {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Schema")
                        .field("fields", &self.fields)
                        .field("primary-key", &self.primary_key)
                        .finish()
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod golem {
        pub mod search_opensearch {
            /// Unified search interface
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod core {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type IndexName = super::super::super::super::golem::search_opensearch::types::IndexName;
                pub type DocumentId = super::super::super::super::golem::search_opensearch::types::DocumentId;
                pub type Doc = super::super::super::super::golem::search_opensearch::types::Doc;
                pub type SearchQuery = super::super::super::super::golem::search_opensearch::types::SearchQuery;
                pub type SearchResults = super::super::super::super::golem::search_opensearch::types::SearchResults;
                pub type Schema = super::super::super::super::golem::search_opensearch::types::Schema;
                pub type SearchError = super::super::super::super::golem::search_opensearch::types::SearchError;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_index_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: *mut u8,
                    arg4: usize,
                    arg5: i32,
                    arg6: *mut u8,
                    arg7: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result11 = T::create_index(
                        _rt::string_lift(bytes0),
                        match arg2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let base9 = arg3;
                                    let len9 = arg4;
                                    let mut result9 = _rt::Vec::with_capacity(len9);
                                    for i in 0..len9 {
                                        let base = base9
                                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                        let e9 = {
                                            let l1 = *base.add(0).cast::<*mut u8>();
                                            let l2 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len3 = l2;
                                            let bytes3 = _rt::Vec::from_raw_parts(
                                                l1.cast(),
                                                len3,
                                                len3,
                                            );
                                            let l4 = i32::from(
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            let l5 = i32::from(
                                                *base
                                                    .add(1 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            let l6 = i32::from(
                                                *base
                                                    .add(2 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            let l7 = i32::from(
                                                *base
                                                    .add(3 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            let l8 = i32::from(
                                                *base
                                                    .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            super::super::super::super::golem::search_opensearch::types::SchemaField {
                                                name: _rt::string_lift(bytes3),
                                                type_: super::super::super::super::golem::search_opensearch::types::FieldType::_lift(
                                                    l4 as u8,
                                                ),
                                                required: _rt::bool_lift(l5 as u8),
                                                facet: _rt::bool_lift(l6 as u8),
                                                sort: _rt::bool_lift(l7 as u8),
                                                index: _rt::bool_lift(l8 as u8),
                                            }
                                        };
                                        result9.push(e9);
                                    }
                                    _rt::cabi_dealloc(
                                        base9,
                                        len9 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    super::super::super::super::golem::search_opensearch::types::Schema {
                                        fields: result9,
                                        primary_key: match arg5 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let len10 = arg7;
                                                    let bytes10 = _rt::Vec::from_raw_parts(
                                                        arg6.cast(),
                                                        len10,
                                                        len10,
                                                    );
                                                    _rt::string_lift(bytes10)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr12 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result11 {
                        Ok(_) => {
                            *ptr12.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr12.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::search_opensearch::types::SearchError as V15;
                            match e {
                                V15::IndexNotFound => {
                                    *ptr12
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                                V15::InvalidQuery(e) => {
                                    *ptr12
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr12
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr12
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V15::Unsupported => {
                                    *ptr12
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                }
                                V15::Internal(e) => {
                                    *ptr12
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr12
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr12
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V15::Timeout => {
                                    *ptr12
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                }
                                V15::RateLimited => {
                                    *ptr12
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                }
                            }
                        }
                    };
                    ptr12
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_create_index<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l1 {
                                0 => {}
                                1 => {
                                    let l2 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                2 => {}
                                3 => {
                                    let l4 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                4 => {}
                                _ => {}
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_delete_index_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::delete_index(_rt::string_lift(bytes0));
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(_) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::search_opensearch::types::SearchError as V5;
                            match e {
                                V5::IndexNotFound => {
                                    *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                                V5::InvalidQuery(e) => {
                                    *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr2
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr2
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V5::Unsupported => {
                                    *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                }
                                V5::Internal(e) => {
                                    *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr2
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V5::Timeout => {
                                    *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                }
                                V5::RateLimited => {
                                    *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_delete_index<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l1 {
                                0 => {}
                                1 => {
                                    let l2 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                2 => {}
                                3 => {
                                    let l4 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                4 => {}
                                _ => {}
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_list_indexes_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::list_indexes();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let vec3 = e;
                            let len3 = vec3.len();
                            let layout3 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec3.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result3 = if layout3.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout3);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec3.into_iter().enumerate() {
                                let base = result3
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len2;
                                    *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                            }
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result3;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::search_opensearch::types::SearchError as V6;
                            match e {
                                V6::IndexNotFound => {
                                    *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                                V6::InvalidQuery(e) => {
                                    *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr1
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V6::Unsupported => {
                                    *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                }
                                V6::Internal(e) => {
                                    *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr1
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V6::Timeout => {
                                    *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                }
                                V6::RateLimited => {
                                    *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_list_indexes<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base5 = l1;
                            let len5 = l2;
                            for i in 0..len5 {
                                let base = base5
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base5,
                                len5 * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {
                            let l6 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l6 {
                                0 => {}
                                1 => {
                                    let l7 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l8 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                                2 => {}
                                3 => {
                                    let l9 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l10 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                                4 => {}
                                _ => {}
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_upsert_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                    arg4: *mut u8,
                    arg5: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let len1 = arg3;
                    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
                    let len2 = arg5;
                    let bytes2 = _rt::Vec::from_raw_parts(arg4.cast(), len2, len2);
                    let result3 = T::upsert(
                        _rt::string_lift(bytes0),
                        super::super::super::super::golem::search_opensearch::types::Doc {
                            id: _rt::string_lift(bytes1),
                            content: _rt::string_lift(bytes2),
                        },
                    );
                    let ptr4 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result3 {
                        Ok(_) => {
                            *ptr4.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr4.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::search_opensearch::types::SearchError as V7;
                            match e {
                                V7::IndexNotFound => {
                                    *ptr4
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                                V7::InvalidQuery(e) => {
                                    *ptr4
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr4
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr4
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V7::Unsupported => {
                                    *ptr4
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                }
                                V7::Internal(e) => {
                                    *ptr4
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr4
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr4
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V7::Timeout => {
                                    *ptr4
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                }
                                V7::RateLimited => {
                                    *ptr4
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                }
                            }
                        }
                    };
                    ptr4
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_upsert<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l1 {
                                0 => {}
                                1 => {
                                    let l2 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                2 => {}
                                3 => {
                                    let l4 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                4 => {}
                                _ => {}
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_upsert_many_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let base7 = arg2;
                    let len7 = arg3;
                    let mut result7 = _rt::Vec::with_capacity(len7);
                    for i in 0..len7 {
                        let base = base7
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e7 = {
                            let l1 = *base.add(0).cast::<*mut u8>();
                            let l2 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len3 = l2;
                            let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
                            let l4 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len6 = l5;
                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                            super::super::super::super::golem::search_opensearch::types::Doc {
                                id: _rt::string_lift(bytes3),
                                content: _rt::string_lift(bytes6),
                            }
                        };
                        result7.push(e7);
                    }
                    _rt::cabi_dealloc(
                        base7,
                        len7 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result8 = T::upsert_many(_rt::string_lift(bytes0), result7);
                    let ptr9 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result8 {
                        Ok(_) => {
                            *ptr9.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr9.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::search_opensearch::types::SearchError as V12;
                            match e {
                                V12::IndexNotFound => {
                                    *ptr9
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                                V12::InvalidQuery(e) => {
                                    *ptr9
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr9
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr9
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V12::Unsupported => {
                                    *ptr9
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                }
                                V12::Internal(e) => {
                                    *ptr9
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr9
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr9
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V12::Timeout => {
                                    *ptr9
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                }
                                V12::RateLimited => {
                                    *ptr9
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                }
                            }
                        }
                    };
                    ptr9
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_upsert_many<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l1 {
                                0 => {}
                                1 => {
                                    let l2 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                2 => {}
                                3 => {
                                    let l4 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                4 => {}
                                _ => {}
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_delete_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let len1 = arg3;
                    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
                    let result2 = T::delete(
                        _rt::string_lift(bytes0),
                        _rt::string_lift(bytes1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(_) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::search_opensearch::types::SearchError as V6;
                            match e {
                                V6::IndexNotFound => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                                V6::InvalidQuery(e) => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr3
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr3
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V6::Unsupported => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                }
                                V6::Internal(e) => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr3
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr3
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V6::Timeout => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                }
                                V6::RateLimited => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                }
                            }
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_delete<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l1 {
                                0 => {}
                                1 => {
                                    let l2 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                2 => {}
                                3 => {
                                    let l4 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                4 => {}
                                _ => {}
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_delete_many_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let base4 = arg2;
                    let len4 = arg3;
                    let mut result4 = _rt::Vec::with_capacity(len4);
                    for i in 0..len4 {
                        let base = base4
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e4 = {
                            let l1 = *base.add(0).cast::<*mut u8>();
                            let l2 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len3 = l2;
                            let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
                            _rt::string_lift(bytes3)
                        };
                        result4.push(e4);
                    }
                    _rt::cabi_dealloc(
                        base4,
                        len4 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result5 = T::delete_many(_rt::string_lift(bytes0), result4);
                    let ptr6 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result5 {
                        Ok(_) => {
                            *ptr6.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr6.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::search_opensearch::types::SearchError as V9;
                            match e {
                                V9::IndexNotFound => {
                                    *ptr6
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                                V9::InvalidQuery(e) => {
                                    *ptr6
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr6
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr6
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V9::Unsupported => {
                                    *ptr6
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                }
                                V9::Internal(e) => {
                                    *ptr6
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr6
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr6
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V9::Timeout => {
                                    *ptr6
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                }
                                V9::RateLimited => {
                                    *ptr6
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                }
                            }
                        }
                    };
                    ptr6
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_delete_many<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l1 {
                                0 => {}
                                1 => {
                                    let l2 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                2 => {}
                                3 => {
                                    let l4 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                4 => {}
                                _ => {}
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let len1 = arg3;
                    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
                    let result2 = T::get(
                        _rt::string_lift(bytes0),
                        _rt::string_lift(bytes1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(e) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                            match e {
                                Some(e) => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let super::super::super::super::golem::search_opensearch::types::Doc {
                                        id: id4,
                                        content: content4,
                                    } = e;
                                    let vec5 = (id4.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr3
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr3
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr5.cast_mut();
                                    let vec6 = (content4.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr3
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr3
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                None => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::search_opensearch::types::SearchError as V9;
                            match e {
                                V9::IndexNotFound => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                                V9::InvalidQuery(e) => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr3
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr3
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V9::Unsupported => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                }
                                V9::Internal(e) => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr3
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr3
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V9::Timeout => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                }
                                V9::RateLimited => {
                                    *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                }
                            }
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l1 {
                                0 => {}
                                _ => {
                                    let l2 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                    let l4 = *arg0
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                            }
                        }
                        _ => {
                            let l6 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l6 {
                                0 => {}
                                1 => {
                                    let l7 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l8 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                                2 => {}
                                3 => {
                                    let l9 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l10 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                                4 => {}
                                _ => {}
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_search_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = i32::from(
                        *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l7 = *arg0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base12 = l7;
                    let len12 = l8;
                    let mut result12 = _rt::Vec::with_capacity(len12);
                    for i in 0..len12 {
                        let base = base12
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e12 = {
                            let l9 = *base.add(0).cast::<*mut u8>();
                            let l10 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len11 = l10;
                            let bytes11 = _rt::Vec::from_raw_parts(
                                l9.cast(),
                                len11,
                                len11,
                            );
                            _rt::string_lift(bytes11)
                        };
                        result12.push(e12);
                    }
                    _rt::cabi_dealloc(
                        base12,
                        len12 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l13 = *arg0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l14 = *arg0
                        .add(8 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base18 = l13;
                    let len18 = l14;
                    let mut result18 = _rt::Vec::with_capacity(len18);
                    for i in 0..len18 {
                        let base = base18
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e18 = {
                            let l15 = *base.add(0).cast::<*mut u8>();
                            let l16 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len17 = l16;
                            let bytes17 = _rt::Vec::from_raw_parts(
                                l15.cast(),
                                len17,
                                len17,
                            );
                            _rt::string_lift(bytes17)
                        };
                        result18.push(e18);
                    }
                    _rt::cabi_dealloc(
                        base18,
                        len18 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l19 = *arg0
                        .add(9 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l20 = *arg0
                        .add(10 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base24 = l19;
                    let len24 = l20;
                    let mut result24 = _rt::Vec::with_capacity(len24);
                    for i in 0..len24 {
                        let base = base24
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e24 = {
                            let l21 = *base.add(0).cast::<*mut u8>();
                            let l22 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len23 = l22;
                            let bytes23 = _rt::Vec::from_raw_parts(
                                l21.cast(),
                                len23,
                                len23,
                            );
                            _rt::string_lift(bytes23)
                        };
                        result24.push(e24);
                    }
                    _rt::cabi_dealloc(
                        base24,
                        len24 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l25 = i32::from(
                        *arg0.add(11 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l27 = i32::from(
                        *arg0
                            .add(8 + 11 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l29 = i32::from(
                        *arg0
                            .add(16 + 11 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l31 = i32::from(
                        *arg0
                            .add(24 + 11 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l48 = i32::from(
                        *arg0
                            .add(32 + 20 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let result76 = T::search(
                        _rt::string_lift(bytes2),
                        super::super::super::super::golem::search_opensearch::types::SearchQuery {
                            q: match l3 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l4 = *arg0
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l5 = *arg0
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len6 = l5;
                                        let bytes6 = _rt::Vec::from_raw_parts(
                                            l4.cast(),
                                            len6,
                                            len6,
                                        );
                                        _rt::string_lift(bytes6)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            filters: result12,
                            sort: result18,
                            facets: result24,
                            page: match l25 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l26 = *arg0
                                            .add(4 + 11 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i32>();
                                        l26 as u32
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            per_page: match l27 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l28 = *arg0
                                            .add(12 + 11 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i32>();
                                        l28 as u32
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            offset: match l29 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l30 = *arg0
                                            .add(20 + 11 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i32>();
                                        l30 as u32
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            highlight: match l31 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l32 = *arg0
                                            .add(24 + 12 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l33 = *arg0
                                            .add(24 + 13 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base37 = l32;
                                        let len37 = l33;
                                        let mut result37 = _rt::Vec::with_capacity(len37);
                                        for i in 0..len37 {
                                            let base = base37
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            let e37 = {
                                                let l34 = *base.add(0).cast::<*mut u8>();
                                                let l35 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len36 = l35;
                                                let bytes36 = _rt::Vec::from_raw_parts(
                                                    l34.cast(),
                                                    len36,
                                                    len36,
                                                );
                                                _rt::string_lift(bytes36)
                                            };
                                            result37.push(e37);
                                        }
                                        _rt::cabi_dealloc(
                                            base37,
                                            len37 * (2 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        let l38 = i32::from(
                                            *arg0
                                                .add(24 + 14 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        let l42 = i32::from(
                                            *arg0
                                                .add(24 + 17 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        let l46 = i32::from(
                                            *arg0
                                                .add(24 + 20 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        super::super::super::super::golem::search_opensearch::types::HighlightConfig {
                                            fields: result37,
                                            pre_tag: match l38 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l39 = *arg0
                                                            .add(24 + 15 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l40 = *arg0
                                                            .add(24 + 16 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len41 = l40;
                                                        let bytes41 = _rt::Vec::from_raw_parts(
                                                            l39.cast(),
                                                            len41,
                                                            len41,
                                                        );
                                                        _rt::string_lift(bytes41)
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                            post_tag: match l42 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l43 = *arg0
                                                            .add(24 + 18 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l44 = *arg0
                                                            .add(24 + 19 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len45 = l44;
                                                        let bytes45 = _rt::Vec::from_raw_parts(
                                                            l43.cast(),
                                                            len45,
                                                            len45,
                                                        );
                                                        _rt::string_lift(bytes45)
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                            max_length: match l46 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l47 = *arg0
                                                            .add(28 + 20 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>();
                                                        l47 as u32
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                        }
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            config: match l48 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l49 = i32::from(
                                            *arg0
                                                .add(32 + 21 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        let l51 = *arg0
                                            .add(40 + 21 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l52 = *arg0
                                            .add(40 + 22 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base57 = l51;
                                        let len57 = l52;
                                        let mut result57 = _rt::Vec::with_capacity(len57);
                                        for i in 0..len57 {
                                            let base = base57
                                                .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                            let e57 = {
                                                let l53 = *base.add(0).cast::<*mut u8>();
                                                let l54 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len55 = l54;
                                                let bytes55 = _rt::Vec::from_raw_parts(
                                                    l53.cast(),
                                                    len55,
                                                    len55,
                                                );
                                                let l56 = *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<f32>();
                                                (_rt::string_lift(bytes55), l56)
                                            };
                                            result57.push(e57);
                                        }
                                        _rt::cabi_dealloc(
                                            base57,
                                            len57 * (3 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        let l58 = *arg0
                                            .add(40 + 23 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l59 = *arg0
                                            .add(40 + 24 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let base63 = l58;
                                        let len63 = l59;
                                        let mut result63 = _rt::Vec::with_capacity(len63);
                                        for i in 0..len63 {
                                            let base = base63
                                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                            let e63 = {
                                                let l60 = *base.add(0).cast::<*mut u8>();
                                                let l61 = *base
                                                    .add(::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len62 = l61;
                                                let bytes62 = _rt::Vec::from_raw_parts(
                                                    l60.cast(),
                                                    len62,
                                                    len62,
                                                );
                                                _rt::string_lift(bytes62)
                                            };
                                            result63.push(e63);
                                        }
                                        _rt::cabi_dealloc(
                                            base63,
                                            len63 * (2 * ::core::mem::size_of::<*const u8>()),
                                            ::core::mem::size_of::<*const u8>(),
                                        );
                                        let l64 = i32::from(
                                            *arg0
                                                .add(40 + 25 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        let l68 = i32::from(
                                            *arg0
                                                .add(40 + 28 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        let l70 = i32::from(
                                            *arg0
                                                .add(44 + 28 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        let l72 = i32::from(
                                            *arg0
                                                .add(48 + 29 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        super::super::super::super::golem::search_opensearch::types::SearchConfig {
                                            timeout_ms: match l49 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l50 = *arg0
                                                            .add(36 + 21 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>();
                                                        l50 as u32
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                            boost_fields: result57,
                                            attributes_to_retrieve: result63,
                                            language: match l64 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l65 = *arg0
                                                            .add(40 + 26 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l66 = *arg0
                                                            .add(40 + 27 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len67 = l66;
                                                        let bytes67 = _rt::Vec::from_raw_parts(
                                                            l65.cast(),
                                                            len67,
                                                            len67,
                                                        );
                                                        _rt::string_lift(bytes67)
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                            typo_tolerance: match l68 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l69 = i32::from(
                                                            *arg0
                                                                .add(41 + 28 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        _rt::bool_lift(l69 as u8)
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                            exact_match_boost: match l70 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l71 = *arg0
                                                            .add(48 + 28 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<f32>();
                                                        l71
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                            provider_params: match l72 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l73 = *arg0
                                                            .add(48 + 30 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l74 = *arg0
                                                            .add(48 + 31 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len75 = l74;
                                                        let bytes75 = _rt::Vec::from_raw_parts(
                                                            l73.cast(),
                                                            len75,
                                                            len75,
                                                        );
                                                        _rt::string_lift(bytes75)
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                        }
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                    );
                    _rt::cabi_dealloc(
                        arg0,
                        48 + 32 * ::core::mem::size_of::<*const u8>(),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let ptr77 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result76 {
                        Ok(e) => {
                            *ptr77.add(0).cast::<u8>() = (0i32) as u8;
                            let super::super::super::super::golem::search_opensearch::types::SearchResults {
                                total: total78,
                                page: page78,
                                per_page: per_page78,
                                hits: hits78,
                                facets: facets78,
                                took_ms: took_ms78,
                            } = e;
                            match total78 {
                                Some(e) => {
                                    *ptr77
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *ptr77
                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(e);
                                }
                                None => {
                                    *ptr77
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match page78 {
                                Some(e) => {
                                    *ptr77
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *ptr77
                                        .add(12 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(e);
                                }
                                None => {
                                    *ptr77
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match per_page78 {
                                Some(e) => {
                                    *ptr77
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *ptr77
                                        .add(20 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(e);
                                }
                                None => {
                                    *ptr77
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec83 = hits78;
                            let len83 = vec83.len();
                            let layout83 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec83.len()
                                    * (16 + 8 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            let result83 = if layout83.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout83).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout83);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec83.into_iter().enumerate() {
                                let base = result83
                                    .add(i * (16 + 8 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let super::super::super::super::golem::search_opensearch::types::SearchHit {
                                        id: id79,
                                        score: score79,
                                        content: content79,
                                        highlights: highlights79,
                                    } = e;
                                    let vec80 = (id79.into_bytes()).into_boxed_slice();
                                    let ptr80 = vec80.as_ptr().cast::<u8>();
                                    let len80 = vec80.len();
                                    ::core::mem::forget(vec80);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len80;
                                    *base.add(0).cast::<*mut u8>() = ptr80.cast_mut();
                                    match score79 {
                                        Some(e) => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            *base
                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<f64>() = _rt::as_f64(e);
                                        }
                                        None => {
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match content79 {
                                        Some(e) => {
                                            *base
                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec81 = (e.into_bytes()).into_boxed_slice();
                                            let ptr81 = vec81.as_ptr().cast::<u8>();
                                            let len81 = vec81.len();
                                            ::core::mem::forget(vec81);
                                            *base
                                                .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len81;
                                            *base
                                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr81.cast_mut();
                                        }
                                        None => {
                                            *base
                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match highlights79 {
                                        Some(e) => {
                                            *base
                                                .add(16 + 5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec82 = (e.into_bytes()).into_boxed_slice();
                                            let ptr82 = vec82.as_ptr().cast::<u8>();
                                            let len82 = vec82.len();
                                            ::core::mem::forget(vec82);
                                            *base
                                                .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len82;
                                            *base
                                                .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr82.cast_mut();
                                        }
                                        None => {
                                            *base
                                                .add(16 + 5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                            }
                            *ptr77
                                .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len83;
                            *ptr77
                                .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result83;
                            match facets78 {
                                Some(e) => {
                                    *ptr77
                                        .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec84 = (e.into_bytes()).into_boxed_slice();
                                    let ptr84 = vec84.as_ptr().cast::<u8>();
                                    let len84 = vec84.len();
                                    ::core::mem::forget(vec84);
                                    *ptr77
                                        .add(24 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len84;
                                    *ptr77
                                        .add(24 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr84.cast_mut();
                                }
                                None => {
                                    *ptr77
                                        .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match took_ms78 {
                                Some(e) => {
                                    *ptr77
                                        .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *ptr77
                                        .add(28 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(e);
                                }
                                None => {
                                    *ptr77
                                        .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr77.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::search_opensearch::types::SearchError as V87;
                            match e {
                                V87::IndexNotFound => {
                                    *ptr77
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                                V87::InvalidQuery(e) => {
                                    *ptr77
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec85 = (e.into_bytes()).into_boxed_slice();
                                    let ptr85 = vec85.as_ptr().cast::<u8>();
                                    let len85 = vec85.len();
                                    ::core::mem::forget(vec85);
                                    *ptr77
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len85;
                                    *ptr77
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr85.cast_mut();
                                }
                                V87::Unsupported => {
                                    *ptr77
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                }
                                V87::Internal(e) => {
                                    *ptr77
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    let vec86 = (e.into_bytes()).into_boxed_slice();
                                    let ptr86 = vec86.as_ptr().cast::<u8>();
                                    let len86 = vec86.len();
                                    ::core::mem::forget(vec86);
                                    *ptr77
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len86;
                                    *ptr77
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr86.cast_mut();
                                }
                                V87::Timeout => {
                                    *ptr77
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                }
                                V87::RateLimited => {
                                    *ptr77
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                }
                            }
                        }
                    };
                    ptr77
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_search<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base11 = l1;
                            let len11 = l2;
                            for i in 0..len11 {
                                let base = base11
                                    .add(i * (16 + 8 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                    let l5 = i32::from(
                                        *base
                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l5 {
                                        0 => {}
                                        _ => {
                                            let l6 = *base
                                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l7 = *base
                                                .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l6, l7, 1);
                                        }
                                    }
                                    let l8 = i32::from(
                                        *base
                                            .add(16 + 5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l8 {
                                        0 => {}
                                        _ => {
                                            let l9 = *base
                                                .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l10 = *base
                                                .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l9, l10, 1);
                                        }
                                    }
                                }
                            }
                            _rt::cabi_dealloc(
                                base11,
                                len11 * (16 + 8 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            let l12 = i32::from(
                                *arg0
                                    .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l12 {
                                0 => {}
                                _ => {
                                    let l13 = *arg0
                                        .add(24 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l14 = *arg0
                                        .add(24 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                            }
                        }
                        _ => {
                            let l15 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l15 {
                                0 => {}
                                1 => {
                                    let l16 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                2 => {}
                                3 => {
                                    let l18 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                4 => {}
                                _ => {}
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_schema_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::get_schema(_rt::string_lift(bytes0));
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let super::super::super::super::golem::search_opensearch::types::Schema {
                                fields: fields3,
                                primary_key: primary_key3,
                            } = e;
                            let vec6 = fields3;
                            let len6 = vec6.len();
                            let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec6.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result6 = if layout6.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout6);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec6.into_iter().enumerate() {
                                let base = result6
                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let super::super::super::super::golem::search_opensearch::types::SchemaField {
                                        name: name4,
                                        type_: type_4,
                                        required: required4,
                                        facet: facet4,
                                        sort: sort4,
                                        index: index4,
                                    } = e;
                                    let vec5 = (name4.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *base.add(0).cast::<*mut u8>() = ptr5.cast_mut();
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (type_4.clone() as i32) as u8;
                                    *base
                                        .add(1 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match required4 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    *base
                                        .add(2 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match facet4 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    *base
                                        .add(3 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match sort4 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    *base
                                        .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match index4 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                }
                            }
                            *ptr2
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len6;
                            *ptr2
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result6;
                            match primary_key3 {
                                Some(e) => {
                                    *ptr2
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr2
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                None => {
                                    *ptr2
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::search_opensearch::types::SearchError as V10;
                            match e {
                                V10::IndexNotFound => {
                                    *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                                V10::InvalidQuery(e) => {
                                    *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr2
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V10::Unsupported => {
                                    *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                }
                                V10::Internal(e) => {
                                    *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr2
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V10::Timeout => {
                                    *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                }
                                V10::RateLimited => {
                                    *ptr2
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_schema<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base5 = l1;
                            let len5 = l2;
                            for i in 0..len5 {
                                let base = base5
                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base5,
                                len5 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l6 = i32::from(
                                *arg0
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l6 {
                                0 => {}
                                _ => {
                                    let l7 = *arg0
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l8 = *arg0
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                            }
                        }
                        _ => {
                            let l9 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l9 {
                                0 => {}
                                1 => {
                                    let l10 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                2 => {}
                                3 => {
                                    let l12 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                4 => {}
                                _ => {}
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_update_schema_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                    arg4: i32,
                    arg5: *mut u8,
                    arg6: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let base9 = arg2;
                    let len9 = arg3;
                    let mut result9 = _rt::Vec::with_capacity(len9);
                    for i in 0..len9 {
                        let base = base9
                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                        let e9 = {
                            let l1 = *base.add(0).cast::<*mut u8>();
                            let l2 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len3 = l2;
                            let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
                            let l4 = i32::from(
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l5 = i32::from(
                                *base
                                    .add(1 + 2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l6 = i32::from(
                                *base
                                    .add(2 + 2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l7 = i32::from(
                                *base
                                    .add(3 + 2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l8 = i32::from(
                                *base
                                    .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            super::super::super::super::golem::search_opensearch::types::SchemaField {
                                name: _rt::string_lift(bytes3),
                                type_: super::super::super::super::golem::search_opensearch::types::FieldType::_lift(
                                    l4 as u8,
                                ),
                                required: _rt::bool_lift(l5 as u8),
                                facet: _rt::bool_lift(l6 as u8),
                                sort: _rt::bool_lift(l7 as u8),
                                index: _rt::bool_lift(l8 as u8),
                            }
                        };
                        result9.push(e9);
                    }
                    _rt::cabi_dealloc(
                        base9,
                        len9 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result11 = T::update_schema(
                        _rt::string_lift(bytes0),
                        super::super::super::super::golem::search_opensearch::types::Schema {
                            fields: result9,
                            primary_key: match arg4 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len10 = arg6;
                                        let bytes10 = _rt::Vec::from_raw_parts(
                                            arg5.cast(),
                                            len10,
                                            len10,
                                        );
                                        _rt::string_lift(bytes10)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                    );
                    let ptr12 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result11 {
                        Ok(_) => {
                            *ptr12.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr12.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::search_opensearch::types::SearchError as V15;
                            match e {
                                V15::IndexNotFound => {
                                    *ptr12
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                                V15::InvalidQuery(e) => {
                                    *ptr12
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr12
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr12
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V15::Unsupported => {
                                    *ptr12
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (2i32) as u8;
                                }
                                V15::Internal(e) => {
                                    *ptr12
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (3i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr12
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr12
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V15::Timeout => {
                                    *ptr12
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (4i32) as u8;
                                }
                                V15::RateLimited => {
                                    *ptr12
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (5i32) as u8;
                                }
                            }
                        }
                    };
                    ptr12
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_update_schema<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(
                                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                            );
                            match l1 {
                                0 => {}
                                1 => {
                                    let l2 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                2 => {}
                                3 => {
                                    let l4 = *arg0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                4 => {}
                                _ => {}
                            }
                        }
                    }
                }
                pub trait Guest {
                    /// Index lifecycle
                    fn create_index(
                        name: IndexName,
                        schema: Option<Schema>,
                    ) -> Result<(), SearchError>;
                    fn delete_index(name: IndexName) -> Result<(), SearchError>;
                    fn list_indexes() -> Result<_rt::Vec<IndexName>, SearchError>;
                    /// Document operations
                    fn upsert(index: IndexName, doc: Doc) -> Result<(), SearchError>;
                    fn upsert_many(
                        index: IndexName,
                        docs: _rt::Vec<Doc>,
                    ) -> Result<(), SearchError>;
                    fn delete(
                        index: IndexName,
                        id: DocumentId,
                    ) -> Result<(), SearchError>;
                    fn delete_many(
                        index: IndexName,
                        ids: _rt::Vec<DocumentId>,
                    ) -> Result<(), SearchError>;
                    fn get(
                        index: IndexName,
                        id: DocumentId,
                    ) -> Result<Option<Doc>, SearchError>;
                    /// Query
                    fn search(
                        index: IndexName,
                        query: SearchQuery,
                    ) -> Result<SearchResults, SearchError>;
                    /// Schema inspection
                    fn get_schema(index: IndexName) -> Result<Schema, SearchError>;
                    fn update_schema(
                        index: IndexName,
                        schema: Schema,
                    ) -> Result<(), SearchError>;
                }
                #[doc(hidden)]
                macro_rules! __export_golem_search_opensearch_core_1_0_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "golem:search-opensearch/core@1.0.0#create-index")] unsafe extern
                        "C" fn export_create_index(arg0 : * mut u8, arg1 : usize, arg2 :
                        i32, arg3 : * mut u8, arg4 : usize, arg5 : i32, arg6 : * mut u8,
                        arg7 : usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_create_index_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4,
                        arg5, arg6, arg7) } } #[unsafe (export_name =
                        "cabi_post_golem:search-opensearch/core@1.0.0#create-index")]
                        unsafe extern "C" fn _post_return_create_index(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*:: __post_return_create_index::<$ty
                        > (arg0) } } #[unsafe (export_name =
                        "golem:search-opensearch/core@1.0.0#delete-index")] unsafe extern
                        "C" fn export_delete_index(arg0 : * mut u8, arg1 : usize,) -> *
                        mut u8 { unsafe { $($path_to_types)*::
                        _export_delete_index_cabi::<$ty > (arg0, arg1) } } #[unsafe
                        (export_name =
                        "cabi_post_golem:search-opensearch/core@1.0.0#delete-index")]
                        unsafe extern "C" fn _post_return_delete_index(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*:: __post_return_delete_index::<$ty
                        > (arg0) } } #[unsafe (export_name =
                        "golem:search-opensearch/core@1.0.0#list-indexes")] unsafe extern
                        "C" fn export_list_indexes() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_list_indexes_cabi::<$ty > () } }
                        #[unsafe (export_name =
                        "cabi_post_golem:search-opensearch/core@1.0.0#list-indexes")]
                        unsafe extern "C" fn _post_return_list_indexes(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*:: __post_return_list_indexes::<$ty
                        > (arg0) } } #[unsafe (export_name =
                        "golem:search-opensearch/core@1.0.0#upsert")] unsafe extern "C"
                        fn export_upsert(arg0 : * mut u8, arg1 : usize, arg2 : * mut u8,
                        arg3 : usize, arg4 : * mut u8, arg5 : usize,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_upsert_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "cabi_post_golem:search-opensearch/core@1.0.0#upsert")] unsafe
                        extern "C" fn _post_return_upsert(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_upsert::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "golem:search-opensearch/core@1.0.0#upsert-many")] unsafe extern
                        "C" fn export_upsert_many(arg0 : * mut u8, arg1 : usize, arg2 : *
                        mut u8, arg3 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_upsert_many_cabi::<$ty > (arg0,
                        arg1, arg2, arg3) } } #[unsafe (export_name =
                        "cabi_post_golem:search-opensearch/core@1.0.0#upsert-many")]
                        unsafe extern "C" fn _post_return_upsert_many(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_upsert_many::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "golem:search-opensearch/core@1.0.0#delete")] unsafe extern "C"
                        fn export_delete(arg0 : * mut u8, arg1 : usize, arg2 : * mut u8,
                        arg3 : usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_delete_cabi::<$ty > (arg0, arg1, arg2, arg3) } } #[unsafe
                        (export_name =
                        "cabi_post_golem:search-opensearch/core@1.0.0#delete")] unsafe
                        extern "C" fn _post_return_delete(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_delete::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "golem:search-opensearch/core@1.0.0#delete-many")] unsafe extern
                        "C" fn export_delete_many(arg0 : * mut u8, arg1 : usize, arg2 : *
                        mut u8, arg3 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_delete_many_cabi::<$ty > (arg0,
                        arg1, arg2, arg3) } } #[unsafe (export_name =
                        "cabi_post_golem:search-opensearch/core@1.0.0#delete-many")]
                        unsafe extern "C" fn _post_return_delete_many(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_delete_many::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "golem:search-opensearch/core@1.0.0#get")] unsafe extern "C" fn
                        export_get(arg0 : * mut u8, arg1 : usize, arg2 : * mut u8, arg3 :
                        usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_get_cabi::<$ty > (arg0, arg1, arg2, arg3) } } #[unsafe
                        (export_name =
                        "cabi_post_golem:search-opensearch/core@1.0.0#get")] unsafe
                        extern "C" fn _post_return_get(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_get::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "golem:search-opensearch/core@1.0.0#search")] unsafe extern "C"
                        fn export_search(arg0 : * mut u8,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_search_cabi::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_golem:search-opensearch/core@1.0.0#search")] unsafe
                        extern "C" fn _post_return_search(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_search::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "golem:search-opensearch/core@1.0.0#get-schema")] unsafe extern
                        "C" fn export_get_schema(arg0 : * mut u8, arg1 : usize,) -> * mut
                        u8 { unsafe { $($path_to_types)*:: _export_get_schema_cabi::<$ty
                        > (arg0, arg1) } } #[unsafe (export_name =
                        "cabi_post_golem:search-opensearch/core@1.0.0#get-schema")]
                        unsafe extern "C" fn _post_return_get_schema(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_get_schema::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "golem:search-opensearch/core@1.0.0#update-schema")] unsafe
                        extern "C" fn export_update_schema(arg0 : * mut u8, arg1 : usize,
                        arg2 : * mut u8, arg3 : usize, arg4 : i32, arg5 : * mut u8, arg6
                        : usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_update_schema_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4,
                        arg5, arg6) } } #[unsafe (export_name =
                        "cabi_post_golem:search-opensearch/core@1.0.0#update-schema")]
                        unsafe extern "C" fn _post_return_update_schema(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*:: __post_return_update_schema::<$ty
                        > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_golem_search_opensearch_core_1_0_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 32 + 6 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 32
                        + 6 * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub use alloc_crate::alloc;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub fn as_f64<T: AsF64>(t: T) -> f64 {
        t.as_f64()
    }
    pub trait AsF64 {
        fn as_f64(self) -> f64;
    }
    impl<'a, T: Copy + AsF64> AsF64 for &'a T {
        fn as_f64(self) -> f64 {
            (*self).as_f64()
        }
    }
    impl AsF64 for f64 {
        #[inline]
        fn as_f64(self) -> f64 {
            self as f64
        }
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_search_library_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::golem::search_opensearch::core::__export_golem_search_opensearch_core_1_0_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::golem::search_opensearch::core);
    };
}
#[doc(inline)]
pub(crate) use __export_search_library_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:golem:search-opensearch@1.0.0:search-library:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1726] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xb9\x0c\x01A\x02\x01\
A\x0c\x01B'\x01q\x06\x0findex-not-found\0\0\x0dinvalid-query\x01s\0\x0bunsupport\
ed\0\0\x08internal\x01s\0\x07timeout\0\0\x0crate-limited\0\0\x04\0\x0csearch-err\
or\x03\0\0\x01s\x04\0\x0aindex-name\x03\0\x02\x01s\x04\0\x0bdocument-id\x03\0\x04\
\x01s\x04\0\x04json\x03\0\x06\x01r\x02\x02id\x05\x07content\x07\x04\0\x03doc\x03\
\0\x08\x01ps\x01ks\x01ky\x01r\x04\x06fields\x0a\x07pre-tag\x0b\x08post-tag\x0b\x0a\
max-length\x0c\x04\0\x10highlight-config\x03\0\x0d\x01o\x02sv\x01p\x0f\x01k\x7f\x01\
kv\x01k\x07\x01r\x07\x0atimeout-ms\x0c\x0cboost-fields\x10\x16attributes-to-retr\
ieve\x0a\x08language\x0b\x0etypo-tolerance\x11\x11exact-match-boost\x12\x0fprovi\
der-params\x13\x04\0\x0dsearch-config\x03\0\x14\x01k\x0e\x01k\x15\x01r\x09\x01q\x0b\
\x07filters\x0a\x04sort\x0a\x06facets\x0a\x04page\x0c\x08per-page\x0c\x06offset\x0c\
\x09highlight\x16\x06config\x17\x04\0\x0csearch-query\x03\0\x18\x01ku\x01r\x04\x02\
id\x05\x05score\x1a\x07content\x13\x0ahighlights\x13\x04\0\x0asearch-hit\x03\0\x1b\
\x01p\x1c\x01r\x06\x05total\x0c\x04page\x0c\x08per-page\x0c\x04hits\x1d\x06facet\
s\x13\x07took-ms\x0c\x04\0\x0esearch-results\x03\0\x1e\x01m\x07\x04text\x07keywo\
rd\x07integer\x05float\x07boolean\x04date\x09geo-point\x04\0\x0afield-type\x03\0\
\x20\x01r\x06\x04names\x04type!\x08required\x7f\x05facet\x7f\x04sort\x7f\x05inde\
x\x7f\x04\0\x0cschema-field\x03\0\"\x01p#\x01r\x02\x06fields$\x0bprimary-key\x0b\
\x04\0\x06schema\x03\0%\x03\0#golem:search-opensearch/types@1.0.0\x05\0\x02\x03\0\
\0\x0aindex-name\x02\x03\0\0\x0bdocument-id\x02\x03\0\0\x03doc\x02\x03\0\0\x0cse\
arch-query\x02\x03\0\0\x0esearch-results\x02\x03\0\0\x0asearch-hit\x02\x03\0\0\x06\
schema\x02\x03\0\0\x0csearch-error\x01B0\x02\x03\x02\x01\x01\x04\0\x0aindex-name\
\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0bdocument-id\x03\0\x02\x02\x03\x02\x01\x03\x04\
\0\x03doc\x03\0\x04\x02\x03\x02\x01\x04\x04\0\x0csearch-query\x03\0\x06\x02\x03\x02\
\x01\x05\x04\0\x0esearch-results\x03\0\x08\x02\x03\x02\x01\x06\x04\0\x0asearch-h\
it\x03\0\x0a\x02\x03\x02\x01\x07\x04\0\x06schema\x03\0\x0c\x02\x03\x02\x01\x08\x04\
\0\x0csearch-error\x03\0\x0e\x01k\x0d\x01j\0\x01\x0f\x01@\x02\x04name\x01\x06sch\
ema\x10\0\x11\x04\0\x0ccreate-index\x01\x12\x01@\x01\x04name\x01\0\x11\x04\0\x0c\
delete-index\x01\x13\x01p\x01\x01j\x01\x14\x01\x0f\x01@\0\0\x15\x04\0\x0clist-in\
dexes\x01\x16\x01@\x02\x05index\x01\x03doc\x05\0\x11\x04\0\x06upsert\x01\x17\x01\
p\x05\x01@\x02\x05index\x01\x04docs\x18\0\x11\x04\0\x0bupsert-many\x01\x19\x01@\x02\
\x05index\x01\x02id\x03\0\x11\x04\0\x06delete\x01\x1a\x01p\x03\x01@\x02\x05index\
\x01\x03ids\x1b\0\x11\x04\0\x0bdelete-many\x01\x1c\x01k\x05\x01j\x01\x1d\x01\x0f\
\x01@\x02\x05index\x01\x02id\x03\0\x1e\x04\0\x03get\x01\x1f\x01j\x01\x09\x01\x0f\
\x01@\x02\x05index\x01\x05query\x07\0\x20\x04\0\x06search\x01!\x01j\x01\x0d\x01\x0f\
\x01@\x01\x05index\x01\0\"\x04\0\x0aget-schema\x01#\x01@\x02\x05index\x01\x06sch\
ema\x0d\0\x11\x04\0\x0dupdate-schema\x01$\x04\0\"golem:search-opensearch/core@1.\
0.0\x05\x09\x04\0,golem:search-opensearch/search-library@1.0.0\x04\0\x0b\x14\x01\
\0\x0esearch-library\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-comp\
onent\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
